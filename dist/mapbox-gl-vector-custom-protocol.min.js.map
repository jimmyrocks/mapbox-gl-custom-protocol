{"version":3,"file":"mapbox-gl-vector-custom-protocol.min.js","sources":["../../src/index.ts"],"sourcesContent":["import {\n    default as maplibregl,\n    Tile,\n    Callback,\n    RequestParameters,\n    ResponseCallback,\n    Cancelable\n} from 'maplibre-gl';\n\ntype MapLibrary = typeof maplibregl & {'_protocols'?: Map<string, LoadFnType>};\ntype LoadFnType = (requestParameters: RequestParameters, callback: ResponseCallback<any>) => Cancelable;\n\nconst getReqObjectUrl = (loadFn: LoadFnType, rawUrl: string, type: 'vector' | 'raster' | 'geojson'):Promise<string> => new Promise((res, rej) => {\n    const requestParameters:RequestParameters = {\n        url: rawUrl,\n        type: type === ('vector' || 'raster') ? 'arrayBuffer' : 'string' //TODO I think rasters show as arrayBuffer for some reason?\n    };\n    // TODO headers?\n\n    const urlCallback = (error?: Error | null, data?: ArrayBuffer | Object, cacheControl?: string | null, expires?: string | null) => {\n        if (error) {\n            rej(error);\n        } else {\n            let preparedData: Uint8Array | string;\n            if (data instanceof ArrayBuffer) {\n                preparedData = new Uint8Array(data as ArrayBuffer);\n            } else {\n                preparedData = JSON.stringify(data);\n            }\n            const blob = new Blob([preparedData]);\n            const url = URL.createObjectURL(blob);\n            res(url);\n        }\n    };\n    loadFn(requestParameters, urlCallback);\n});\n\nconst CustomProtocol = (mapLibrary: MapLibrary) => {\n\n    // Adds the protocol tools to the mapLibrary, doesn't overwrite them if they already exist\n    const alreadySupported = mapLibrary.addProtocol !== undefined && mapLibrary._protocols === undefined;\n    if (!alreadySupported) {\n        mapLibrary._protocols = mapLibrary._protocols || new Map<string, LoadFnType>();\n        mapLibrary.addProtocol = mapLibrary.addProtocol || ((customProtocol: string, loadFn: LoadFnType) => {\n            mapLibrary._protocols?.set(customProtocol, loadFn);\n        });\n        mapLibrary.removeProtocol = mapLibrary.removeProtocol || ((customProtocol: string) => {\n            mapLibrary._protocols?.delete(customProtocol);\n        });\n    }\n\n    return {\n        'vector': class VectorCustomProtocolSourceSpecification extends mapLibrary.Style.getSourceType('vector') {\n\n            constructor() {\n                super(...arguments);\n            }\n\n            loadTile(tile: Tile, callback: Callback<void>) {\n                const rawUrl = tile.tileID.canonical.url((this as any).tiles, (this as any).scheme);\n                const protocol = rawUrl.substring(0, rawUrl.indexOf('://'));\n                if (!alreadySupported && mapLibrary._protocols?.has(protocol)) {\n                    const loadFn = mapLibrary._protocols?.get(protocol) as LoadFnType;\n                    getReqObjectUrl(loadFn, rawUrl, (this as any).type).then((url: string) => {\n                        tile.tileID.canonical.url = function () {\n                            delete (tile.tileID.canonical as any).url;\n                            return url;\n                        };\n                        super.loadTile(tile, function() {\n                            URL.revokeObjectURL(url);\n                            callback(...arguments);\n                        });\n                    }).catch((e: Error) => {\n                        console.error('Error loading tile', e.message);\n                        throw e;\n                    });\n                } else {\n                    super.loadTile(tile, callback);\n                }\n            }\n        },\n        'raster': class RasterCustomProtocolSourceSpecification extends mapLibrary.Style.getSourceType('raster') {\n\n            constructor() {\n                super(...arguments);\n            }\n\n            loadTile(tile: Tile, callback: Callback<void>) {\n                const rawUrl = tile.tileID.canonical.url((this as any).tiles, (this as any).scheme);\n                const protocol = rawUrl.substring(0, rawUrl.indexOf('://'));\n                if (!alreadySupported && mapLibrary._protocols?.has(protocol)) {\n                    const loadFn = mapLibrary._protocols?.get(protocol) as LoadFnType;\n                    getReqObjectUrl(loadFn, rawUrl, (this as any).type).then((url: string) => {\n                        tile.tileID.canonical.url = function () {\n                            delete (tile.tileID.canonical as any).url;\n                            return url;\n                        };\n                        super.loadTile(tile, function() {\n                            URL.revokeObjectURL(url);\n                            callback(...arguments);\n                        });\n                    }).catch((e: Error) => {\n                        console.error('Error loading tile', e.message);\n                        throw e;\n                    });\n\n\n                } else {\n                    super.loadTile(tile, callback);\n                }\n            }\n        },\n        'geojson': class GeoJSONCustomProtocolSourceSpecification extends mapLibrary.Style.getSourceType('geojson') {\n\n            type: 'geojson';\n\n            constructor() {\n                super(...arguments);\n                this.type = 'geojson';\n            }\n\n            _updateWorkerData(callback: Callback<void>) {\n\n                const that = (this as any);\n                const data = that._data;\n                const done = () => {\n                    super._updateWorkerData(callback);\n                };\n\n                if (typeof data === 'string') {\n                    const protocol = data.substring(0, data.indexOf('://'));\n                    if (!alreadySupported && mapLibrary._protocols?.has(protocol)) {\n                        const loadFn = mapLibrary._protocols?.get(protocol) as LoadFnType;\n\n                        getReqObjectUrl(loadFn, data, (this as any).type).then((url: string) => {\n                            that._data = url;\n                            done();\n                        });\n                    } else {\n                        // Use the build in code\n                        done();\n                    }\n                } else {\n                    // If data is already GeoJSON, then pass it through\n                    done();\n                }\n\n            }\n        }\n    }\n};\n\nexport default CustomProtocol;"],"names":["getReqObjectUrl","loadFn","rawUrl","type","Promise","res","rej","url","error","data","cacheControl","expires","preparedData","ArrayBuffer","Uint8Array","JSON","stringify","blob","Blob","URL","createObjectURL","mapLibrary","alreadySupported","undefined","addProtocol","_protocols","Map","customProtocol","set","removeProtocol","delete","vector","Style","getSourceType","constructor","super","arguments","loadTile","tile","callback","tileID","canonical","this","tiles","scheme","protocol","substring","indexOf","has","get","then","revokeObjectURL","catch","e","console","message","raster","geojson","_updateWorkerData","that","_data","done"],"mappings":"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"}