{"version":3,"file":"mapbox-gl-custom-protocol.min.js","sources":["../../src/index.ts"],"sourcesContent":["import {\n    default as maplibregl,\n    Tile,\n    Callback,\n    RequestParameters,\n    ResponseCallback,\n    Cancelable\n} from 'maplibre-gl';\n\ntype MapLibrary = typeof maplibregl & { '_protocols'?: Map<string, LoadFnType> };\ntype LoadFnType = (requestParameters: RequestParameters, callback: ResponseCallback<any>) => Cancelable;\n\nconst getReqObjectUrl = (loadFn: LoadFnType, rawUrl: string, type: 'vector' | 'raster' | 'geojson', collectResourceTiming?: boolean): Promise<string> => new Promise((res, rej) => {\n    let requestParameters: RequestParameters = {\n        url: rawUrl,\n        type: type === ('vector' || 'raster') ? 'arrayBuffer' : 'string',\n        collectResourceTiming: collectResourceTiming\n    };\n    if (type === 'raster') {\n        requestParameters.headers = {\n            accept: \"image/webp,*/*\"\n        };\n    }\n\n\n    const urlCallback = (error?: Error | null, data?: ArrayBuffer | Object, cacheControl?: string | null, expires?: string | null) => {\n        if (error) {\n            rej(error);\n        } else {\n            let preparedData: Uint8Array | string;\n            if (data instanceof ArrayBuffer) {\n                preparedData = new Uint8Array(data as ArrayBuffer);\n            } else {\n                preparedData = JSON.stringify(data);\n            }\n            const blob = new Blob([preparedData]);\n            const url = URL.createObjectURL(blob);\n            res(url);\n        }\n    };\n    loadFn(requestParameters, urlCallback);\n});\n\nconst CustomProtocol = (mapLibrary: MapLibrary) => {\n\n    // Adds the protocol tools to the mapLibrary, doesn't overwrite them if they already exist\n    const alreadySupported = mapLibrary.addProtocol !== undefined && mapLibrary._protocols === undefined;\n    if (!alreadySupported) {\n        mapLibrary._protocols = mapLibrary._protocols || new Map<string, LoadFnType>();\n        mapLibrary.addProtocol = mapLibrary.addProtocol || ((customProtocol: string, loadFn: LoadFnType) => {\n            mapLibrary._protocols?.set(customProtocol, loadFn);\n        });\n        mapLibrary.removeProtocol = mapLibrary.removeProtocol || ((customProtocol: string) => {\n            mapLibrary._protocols?.delete(customProtocol);\n        });\n    }\n\n    return {\n        'vector': class VectorCustomProtocolSourceSpecification extends mapLibrary.Style.getSourceType('vector') {\n\n            constructor() {\n                super(...arguments);\n            }\n\n            loadTile(tile: Tile, callback: Callback<void>) {\n                const rawUrl = tile.tileID.canonical.url((this as any).tiles, (this as any).scheme);\n                const protocol = rawUrl.substring(0, rawUrl.indexOf('://'));\n                if (!alreadySupported && mapLibrary._protocols?.has(protocol)) {\n                    const loadFn = mapLibrary._protocols?.get(protocol) as LoadFnType;\n                    getReqObjectUrl(loadFn, rawUrl, (this as any).type, (this as any)._collectResourceTiming).then((url: string) => {\n                        tile.tileID.canonical.url = function () {\n                            delete (tile.tileID.canonical as any).url;\n                            return url;\n                        };\n                        super.loadTile(tile, function () {\n                            URL.revokeObjectURL(url);\n                            callback(...arguments);\n                        });\n                    }).catch((e: Error) => {\n                        console.error('Error loading tile', e.message);\n                        throw e;\n                    });\n                } else {\n                    super.loadTile(tile, callback);\n                }\n            }\n        },\n        'raster': class RasterCustomProtocolSourceSpecification extends mapLibrary.Style.getSourceType('raster') {\n\n            constructor() {\n                super(...arguments);\n            }\n\n            loadTile(tile: Tile, callback: Callback<void>) {\n                const rawUrl = tile.tileID.canonical.url((this as any).tiles, (this as any).scheme);\n                const protocol = rawUrl.substring(0, rawUrl.indexOf('://'));\n                if (!alreadySupported && mapLibrary._protocols?.has(protocol)) {\n                    const loadFn = mapLibrary._protocols?.get(protocol) as LoadFnType;\n                    getReqObjectUrl(loadFn, rawUrl, (this as any).type, (this as any)._collectResourceTiming).then((url: string) => {\n                        tile.tileID.canonical.url = function () {\n                            delete (tile.tileID.canonical as any).url;\n                            return url;\n                        };\n                        super.loadTile(tile, function () {\n                            URL.revokeObjectURL(url);\n                            callback(...arguments);\n                        });\n                    }).catch((e: Error) => {\n                        console.error('Error loading tile', e.message);\n                        throw e;\n                    });\n\n\n                } else {\n                    super.loadTile(tile, callback);\n                }\n            }\n        },\n        'geojson': class GeoJSONCustomProtocolSourceSpecification extends mapLibrary.Style.getSourceType('geojson') {\n\n            type: 'geojson';\n\n            constructor() {\n                super(...arguments);\n                this.type = 'geojson';\n            }\n\n            _updateWorkerData(callback: Callback<void>) {\n\n                const that = (this as any);\n                const data = that._data;\n                const done = (url?: string) => {\n                    super._updateWorkerData(function () {\n                        if (url !== undefined) {\n                            URL.revokeObjectURL(url);\n                        }\n                        callback(...arguments);\n                    });\n                };\n\n                if (typeof data === 'string') {\n                    const protocol = data.substring(0, data.indexOf('://'));\n                    if (!alreadySupported && mapLibrary._protocols?.has(protocol)) {\n                        const loadFn = mapLibrary._protocols?.get(protocol) as LoadFnType;\n\n                        getReqObjectUrl(loadFn, data, (this as any).type, (this as any)._collectResourceTiming).then((url: string) => {\n                            that._data = url;\n                            done(url);\n                        });\n                    } else {\n                        // Use the build in code\n                        done();\n                    }\n                } else {\n                    // If data is already GeoJSON, then pass it through\n                    done();\n                }\n\n            }\n        }\n    }\n};\n\nexport default CustomProtocol;"],"names":["getReqObjectUrl","loadFn","rawUrl","type","collectResourceTiming","Promise","res","rej","requestParameters","url","headers","accept","error","data","cacheControl","expires","preparedData","ArrayBuffer","Uint8Array","JSON","stringify","blob","Blob","URL","createObjectURL","mapLibrary","alreadySupported","undefined","addProtocol","_protocols","Map","customProtocol","set","removeProtocol","delete","vector","Style","getSourceType","constructor","super","arguments","loadTile","tile","callback","tileID","canonical","this","tiles","scheme","protocol","substring","indexOf","has","get","_collectResourceTiming","then","revokeObjectURL","catch","e","console","message","raster","geojson","_updateWorkerData","that","_data","done"],"mappings":"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"}